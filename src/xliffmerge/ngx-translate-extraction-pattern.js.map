{"version":3,"file":"ngx-translate-extraction-pattern.js","sourceRoot":"","sources":["../../../../projects/xliffmerge/src/xliffmerge/ngx-translate-extraction-pattern.ts"],"names":[],"mappings":";;AAAA;;;GAGG;AACH,MAAa,6BAA6B;IAKtC;;;;OAIG;IACH,YAAoB,uBAA+B;QAA/B,4BAAuB,GAAvB,uBAAuB,CAAQ;QAC/C,MAAM,KAAK,GAAG,uBAAuB,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACjD,IAAI,CAAC,gBAAgB,GAAG,KAAK,CAAC;QAC9B,IAAI,CAAC,oBAAoB,GAAG,EAAE,CAAC;QAC/B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACnC,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACtB,IAAI,IAAI,KAAK,IAAI,EAAE;gBACf,IAAI,IAAI,CAAC,gBAAgB,EAAE;oBACvB,MAAM,IAAI,KAAK,CAAC,8CAA8C,CAAC,CAAC;iBACnE;gBACD,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC;aAChC;iBAAM;gBACH,MAAM,WAAW,GAAG,IAAI,CAAC,4BAA4B,CAAC,IAAI,CAAC,CAAC;gBAC5D,IAAI,WAAW,EAAE;oBACb,MAAM,IAAI,KAAK,CAAC,WAAW,CAAC,CAAC;iBAChC;gBACD,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aACxC;SACJ;IACL,CAAC;IAED;;;;OAIG;IACI,mBAAmB,CAAC,EAAU;QACjC,OAAO,EAAE,IAAI,IAAI,CAAC,gBAAgB,CAAC;IACvC,CAAC;IAED;;;;OAIG;IACI,oBAAoB,CAAC,WAAmB;QAC3C,OAAO,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;IAC/D,CAAC;IAEO,4BAA4B,CAAC,kBAA0B;QAC3D,IAAI,CAAC,kBAAkB,EAAE;YACrB,OAAO,yBAAyB,CAAC;SACpC;QACD,IAAI,wBAAwB,CAAC,IAAI,CAAC,kBAAkB,CAAC,EAAE;YACnD,OAAO,IAAI,CAAC,CAAC,WAAW;SAC3B;aAAM;YACH,OAAO,mFAAmF,CAAC;SAC9F;IACL,CAAC;CACJ;AA3DD,sEA2DC","sourcesContent":["/**\n * Helper class to parse ngx translate extraction pattern\n * and to decide wether a given message matches the pattern.\n */\nexport class NgxTranslateExtractionPattern {\n\n    private _matchExplicitId: boolean;\n    private _descriptionPatterns: string[];\n\n    /**\n     * Construct the pattern from given description string\n     * @param extractionPatternString extractionPatternString\n     * @throws an error, if there is a syntax error\n     */\n    constructor(private extractionPatternString: string) {\n        const parts = extractionPatternString.split('|');\n        this._matchExplicitId = false;\n        this._descriptionPatterns = [];\n        for (let i = 0; i < parts.length; i++) {\n            const part = parts[i];\n            if (part === '@@') {\n                if (this._matchExplicitId) {\n                    throw new Error('extraction pattern must not contain @@ twice');\n                }\n                this._matchExplicitId = true;\n            } else {\n                const errorString = this.checkValidDescriptionPattern(part);\n                if (errorString) {\n                    throw new Error(errorString);\n                }\n                this._descriptionPatterns.push(part);\n            }\n        }\n    }\n\n    /**\n     * Check, wether an explicitly set id matches the pattern.\n     * @param id id\n     * @return wether an explicitly set id matches the pattern.\n     */\n    public isExplicitIdMatched(id: string): boolean {\n        return id && this._matchExplicitId;\n    }\n\n    /**\n     * Check, wether a given description matches the pattern.\n     * @param description description\n     * @return wether a given description matches the pattern.\n     */\n    public isDescriptionMatched(description: string): boolean {\n        return this._descriptionPatterns.indexOf(description) >= 0;\n    }\n\n    private checkValidDescriptionPattern(descriptionPattern: string): string {\n        if (!descriptionPattern) {\n            return 'empty value not allowed';\n        }\n        if (/^[a-zA-Z_][a-zA-Z_-]*$/.test(descriptionPattern)) {\n            return null; // it is ok\n        } else {\n            return 'description pattern must be an identifier containing only letters, digits, _ or -';\n        }\n    }\n}\n"]}